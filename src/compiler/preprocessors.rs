/// This file describes the intermediate representation of an Instruction set
/// as generated by the compiler preprocess pass
///

use crate::ast::{
    Const,
    BinaryOp,
    BinaryOp::*,
    NumericalOp,
    ComparisonOp,
    LogicalOp,
    UnaryOp,
};

pub type Label = usize;

#[derive(Debug,Clone,PartialEq)]
pub enum PreValue {
    /// any quoted string
    Str(String),
    /// int or float
    Num(f64),
    /// boolean `true` or `false`
    Bool(bool),
    /// A function address
    Function(Label),
    /// 
    Null,
    /// 
    Undefined,
}
impl PreValue {
    pub fn from_const(expr: &Const) -> Self { 
        return match *expr {
            Const::Str(ref s) => Self::Str(s.clone()),
            Const::Num(n) => Self::Num(n),
            Const::Bool(b) => Self::Bool(b),
            Const::Null => Self::Null,
            Const::Undefined => Self::Undefined,
        };
    }
}

#[derive(Debug,Clone,PartialEq,Copy)]
pub enum AddrKind {
    Jump,
    BeginLoop,
    EndLoop,
    BeginFunction,
    EndFunction,
}

#[derive(Debug,Clone,PartialEq,Copy)]
pub struct Addr {
    pub kind: AddrKind,
    pub addr: Label,
}

/// This struct's only job is to generates uniq 
/// addresses
#[derive(Debug,Clone,PartialEq)]
pub struct LabelGenerator {
    addr: Label,
}

impl Iterator for LabelGenerator {
    type Item = Label;

    fn next(&mut self) -> Option<Self::Item> {
        let addr = self.addr;
        self.addr += 1;
        Some(addr)
    }
}

impl LabelGenerator {
    pub fn new() -> Self {
        Self { addr: 0 }
    }

    /// Returns an unused `begin loop` address
    pub fn begin_loop(&mut self) -> Addr {
        Addr { 
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::BeginLoop,
        }
    }

    /// Returns an unused `end loop` address
    pub fn end_loop(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::EndLoop,
        }
    }

    /// Returns an unused `jump to` address
    pub fn jump_to(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::Jump,
        }
    }

    /// Returns an unused `begin function` label address
    pub fn begin_function(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::BeginFunction,
        }
    }

    /// Returns an unused `end function` label address
    pub fn end_function(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::EndFunction,
        }
    }

}

#[derive(Debug,Clone,PartialEq)]
pub enum PreInstruction {
    // jump
    Goto(Label),
    GotoIf(Label),
    AddrLabel(Addr),
    Break,
    Continue,
    // Variable bindings
    NewRef(String), 
    Load(String),
    /// pop the stack and store the value into the variable pointed by `String`
    /// if the stack is empty, store `Value::Undefined`
    Store(String), 
    // value 
    Val(PreValue),
    // Arguments and return value
    /// Call a function
    FnCall, // doesn't need to push a new stack, but must create a new environnement
    /// Exit a function
    FnRet,  // doesn't need to pop a stack, but must delete the last environnement
    // stack machine states
    /// move the `n` last elements of the current stack to a passthrough buffer
    PushToNext(usize),
    /// Creates a new stack
    /// then, if any element are in the passthrough buffer push those elements to it
    NewStack,
    /// clear all values of the current stack
    ClearStack,
    /// remove the last stack
    /// then if any element are in the passthrough buffer push those elements to the current one
    DelStack,
    /// Creates a new Loop context
    NewLoopCtx,
    /// remove the last loop context
    DelLoopCtx,
    /// remove the last loop context
    PopToLoopCtx,
    // Native function
    // ... TODO
    // Binary Instructions
    // * Numerical
    Add,
    Sub,
    Div,
    Mul,
    Pow,
    Mod,
    // * Comparison
    Equal,
    NotEqual,
    GreaterThan,
    GreaterThanOrEqual,
    LessThan,
    LessThanOrEqual,
    // * Logical
    And,
    Or,
    // Unary Instructions
    Minus,
    Plus,
    Not,
}
use PreInstruction::*;

/// Build the intructions needed to run a `Const` expression
pub fn preprocess_const(c: &Const) -> Option<Vec<PreInstruction>> {
    Some(vec![Val(PreValue::from_const(c))])
}

/// Build the intructions needed to run a `Break` expression
pub fn preprocess_break() -> Option<Vec<PreInstruction>> {
    Some(vec![Break])
}

/// Build the intructions needed to run a `Continue` expression
pub fn preprocess_continue() -> Option<Vec<PreInstruction>> {
    Some(vec![PopToLoopCtx, Continue])
}

/// Build the intructions needed to run a `return` expression
/// If no expression follows the `return`, a PreValue::Null is returned
/// So `return <expr>;` is compiled as:
///     <expr>
///     PushToNext(1)
///     FnRet
pub fn preprocess_return(mut sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions = Vec::new();
    match sub_instructions.pop() {
        Some(sub_instr) => {
            instructions.extend(sub_instr);
        },
        None => {
            // a function that returns nothing actually 
            // returns Undefined
            instructions.push(Val(PreValue::Undefined));
        }
    }
    instructions.push(PushToNext(1));
    instructions.push(FnRet);
    Some(instructions)
}

/// Build the intructions needed to run a `block` expressions
/// each block creates a new value stack,
/// each expression in a block must operate on an empty stack
///  `{ <expr_a>; <expr_b>; }` is compiled as
///     NewStack
///     <expr_a>
///     ClearStack
///     <expr_b>
///     DelStack
pub fn preprocess_block(sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions: Vec<PreInstruction> = Vec::new();
    instructions.push(NewStack);
    for (i, sub_inst) in sub_instructions.into_iter().enumerate() {
        if i > 0 {
            // each expression must run in a clear stack
            instructions.push(ClearStack);
        }
        instructions.extend(sub_inst);
    }
    instructions.push(DelStack);
    Some(instructions)
}

/// Build the intructions needed to run an `If` expressions
/// So `if (<expr_cond>) { <expr_true> } else { <expr_false> }` is compiled as:
///     <expr_cond>
///     GotoIf 'label_true'
///     <expr_false>
///     Goto 'end'
///     AddrLabel 'label_true'
///     <expr_true>
///     AddrLabel 'end'
pub fn preprocess_if(mut sub_instructions: Vec<Vec<PreInstruction>>, labels: &mut LabelGenerator) -> Option<Vec<PreInstruction>> {
    let mut instructions = Vec::new();
    let true_block_label = labels.jump_to();
    let end = labels.jump_to();

    sub_instructions.reverse();
    let cond_block = sub_instructions.pop()?;
    let true_block = sub_instructions.pop()?;
    let false_block = sub_instructions.pop();

    // conditions
    instructions.extend(cond_block);
    instructions.push(GotoIf(true_block_label.addr));
    // false block
    if let Some(false_block) = false_block {
        instructions.extend(false_block);
    }
    instructions.push(Goto(end.addr));
    // true block
    instructions.push(AddrLabel(true_block_label));
    instructions.extend(true_block);
    // end (needed after the execution of the false block)
    instructions.push(AddrLabel(end));

    Some(instructions)
}

/// Build the instructions needed to run a LetDecl expression.
/// * `let id = <expr>`  is compiled as:
///     <expr>
///     NewRef 'id'
///     Store 'id'
/// *`let id;`  is compiled as:
///     NewRef 'id'
pub fn preprocess_let(id: &str, mut sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions = Vec::new();
    if let Some(sub_inst) = sub_instructions.pop() {
        instructions.extend(sub_inst);
        instructions.push(NewRef(id.into()));
        instructions.push(Store(id.into()));
    } else {
        instructions.push(NewRef(id.into()));
    }
    Some(instructions)
}

/// Build the instructions needed to run a Local expression.
/// `a`  is compiled as:
///     Load 'a'
pub fn preprocess_local(id: &str) -> Option<Vec<PreInstruction>> {
    Some(vec![Load(id.into())])
}

/// Build the intructions needed to run a Call expression
/// So `<expr_called>(<expr_a>, <expr_b>);` is compiled as:
///     <expr_b>
///     <expr_a>        // order so the first poped is the first arg
///     PushToNext(2)   // push the 2 args
///     <expr_called>
///     FnCall
pub fn preprocess_call(mut sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions = Vec::new();
    // set in order <arg 2>, <arg 1>, <arg 0>, <expr called> 
    sub_instructions.reverse();
    let expr_called = sub_instructions.pop()?;
    let arg_nb = sub_instructions.len();
    for sub_inst in sub_instructions {
        // evaluate args
        instructions.extend(sub_inst);
    }
    // push args to the next stack
    if arg_nb > 0 {
        instructions.push(PushToNext(arg_nb));
    }
    // evaluate the called expression
    instructions.extend(expr_called);
    // perform the Call itself
    instructions.push(FnCall);

    Some(instructions)
}

/// Build the intructions needed to run a FunctionDecl expression
/// So `function id(a, b) { <expr> }` is compiled as:
///     Goto(end)       // skip the function block if were not calling it
///     AddrLabel(start)    // address of the function
///     NewRef 'a'      // args
///     Store 'a'
///     NewRef 'b'
///     Store 'b'
///     <expr>              // the function block instructions
///     PreValue(Undefined)    // Return a value no matter what
///     PushToNext(1)
///     FnRet               // quit the function evaluation 
///     AddrLabel(end)          // the piece of code that is executed when the function is 
///                         // declared
///     PreValue(start) // Put the address of the function into a var `id`
///     NewRef 'id'
///     Store 'id'
///     
/// Note: this function will remove the `NewStack` and `DelStack` of the function block
/// TODO: replace `name` by an expression
pub fn preprocess_function_decl(
    mut sub_instructions: Vec<Vec<PreInstruction>>,
    name: &str,
    args: &Vec<String>,
    labels: &mut LabelGenerator) -> Option<Vec<PreInstruction>> {
    let mut instructions = Vec::new();
    // set the address of the function start and end
    let start = labels.begin_function();
    let end = labels.end_function();
    // avoid evaluating the function if were not calling it
    instructions.push(Goto(end.addr));
    // set the `start` label here
    instructions.push(AddrLabel(start)); 
    
    // load args
    for arg in args {
        instructions.push(NewRef(arg.clone()));
        instructions.push(Store(arg.clone()));
    }
    
    // process the function block
    let mut block = sub_instructions.pop()?;
    //delete the NewStack, its redondant
    block.remove(0);
    //delete the DelStack, its redondant
    let _ = block.pop()?;
    // insert the instruction block
    instructions.extend(block);

    // insert a return statement in case none are defined in the block
    match instructions.last() {
        Some(FnRet) => {},
        _ => {
            instructions.push(Val(PreValue::Undefined));
            instructions.push(PushToNext(1));
            instructions.push(FnRet);
        },
    }
    
    // set the end address
    instructions.push(AddrLabel(end)); 

    // set the variable that will hold the function address
    instructions.push(Val(PreValue::Function(start.addr)));
    instructions.push(NewRef(name.into()));
    instructions.push(Store(name.into()));

    Some(instructions)
}

/// Build the intructions needed to run a numerical BinaryOp
/// So `<expr_a> + <expr_b>` is compiled as:
///     <expr_b>
///     <expr_a>
///     Add
pub fn preprocess_numerical_op(op: &NumericalOp, mut sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions = Vec::new();
    // last instruction must be at the bottom of the stack
    instructions.extend(sub_instructions.pop()?);
    instructions.extend(sub_instructions.pop()?);
    // append the actual Operation instruction
    let operation_instruction = match *op {
        NumericalOp::Add => PreInstruction::Add,
        NumericalOp::Sub => PreInstruction::Sub,
        NumericalOp::Div => PreInstruction::Div,
        NumericalOp::Mul => PreInstruction::Mul,
        NumericalOp::Pow => PreInstruction::Pow,
        NumericalOp::Mod => PreInstruction::Mod,
    };
    instructions.push(operation_instruction);
    Some(instructions)
}

/// Build the intructions needed to run a comparison BinaryOp
/// So `<expr_a> > <expr_b>` is compiled as:
///     <expr_b>
///     <expr_a>
///     GreaterThan
pub fn preprocess_comparison_op(op: &ComparisonOp, mut sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions = Vec::new();
    // last instruction must be at the bottom of the stack
    instructions.extend(sub_instructions.pop()?);
    instructions.extend(sub_instructions.pop()?);
    // append the actual Operation instruction
    let operation_instruction = match *op {
        ComparisonOp::Equal => PreInstruction::Equal,
        ComparisonOp::NotEqual => PreInstruction::NotEqual,
        ComparisonOp::GreaterThan => PreInstruction::GreaterThan,
        ComparisonOp::GreaterThanOrEqual => PreInstruction::GreaterThanOrEqual,
        ComparisonOp::LessThan => PreInstruction::LessThan,
        ComparisonOp::LessThanOrEqual => PreInstruction::LessThanOrEqual,
    };
    instructions.push(operation_instruction);
    Some(instructions)
}

/// Build the intructions needed to run a Logical binary operation, eg `&&` and `||`.
/// Handle shortcut evaluation
/// * So `<expr_a> && <expr_b>` is compiled as:
///     <expr_a>
///     GotoIf 'right_hand'
///     Goto 'end'
///     AddrLabel 'right_hand'
///     <expr_b>
///     And
///     AddrLabel 'end'
/// * So `<expr_a> || <expr_b>` is compiled as:
///     <expr_a>
///     GotoIf 'end'
///     <expr_b>
///     Or
///     AddrLabel 'end'
pub fn preprocess_logical_op(op: &LogicalOp, mut sub_instructions: Vec<Vec<PreInstruction>>, labels: &mut LabelGenerator) -> Option<Vec<PreInstruction>> {
    // avoid evaluating the function if were not calling it
    let right_hand = sub_instructions.pop()?;
    // process the left hand of the `and`
    let mut instructions = sub_instructions.pop()?;
    // prepare the `end` label
    let end = labels.jump_to();
    // append the actual Operation instructions
    match *op {
        LogicalOp::And => {
            let right_label = labels.jump_to();
            instructions.push(GotoIf(right_label.addr)); 
            instructions.push(Goto(end.addr)); 
            instructions.push(AddrLabel(right_label)); 
            instructions.extend(right_hand);
            instructions.push(And); 

        },
        LogicalOp::Or => {
            instructions.push(GotoIf(end.addr)); 
            instructions.extend(right_hand);
            instructions.push(Or); 
        },
    };
    instructions.push(AddrLabel(end)); 

    Some(instructions)
}


/// Build the intructions needed to run a Assign BinaryOp
/// So `id = <expr>` is compiled as:
///     <expr>
///     Assign(id)
pub fn assign_to_instructions(name: &str, mut sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions = sub_instructions.pop()?;
    instructions.push(Store(name.into()));
    Some(instructions)
}

/// Build the intructions needed to run an UnaryOp
/// * So `! <expr>` is compiled as:
///     <expr>
///     Not
/// * So `+ <expr>` is compiled as:
///     <expr>
///     Plus
/// * So `- <expr>` is compiled as:
///     <expr>
///     Not
pub fn preprocess_unary_op(op: &UnaryOp, mut sub_instructions: Vec<Vec<PreInstruction>>) -> Option<Vec<PreInstruction>> {
    let mut instructions = sub_instructions.pop()?;
    let inst = match *op {
        UnaryOp::Minus => PreInstruction::Minus,
        UnaryOp::Plus => PreInstruction::Plus,
        UnaryOp::Not => PreInstruction::Not,
    };
    instructions.push(inst);
    Some(instructions)
}

/// Build the intructions needed to run WhileLoop
/// * So `while (<cond_expr>) { <block_expr>}` is compiled as:
///     NewLoopCtx
///     Label 'start_loop'
///     <cond_expr>
///     GotoIf 'block'
///     Goto 'end'
///     Label 'block'
///     <block_expr>
///     Goto 'start_loop'
///     Label 'end_loop'
///     DelLoopCtx
pub fn preprocess_while(mut sub_instructions: Vec<Vec<PreInstruction>>, labels: &mut LabelGenerator) -> Option<Vec<PreInstruction>> {
    // build label
    let begin = labels.begin_loop();
    let block_label = labels.jump_to();
    let end = labels.end_loop();
    // gather expressions
    let block = sub_instructions.pop()?;
    let condition = sub_instructions.pop()?;
    // build the instruction set
    let mut instructions = Vec::new();
    instructions.push(NewLoopCtx);
    instructions.push(AddrLabel(begin));
    instructions.extend(condition);
    instructions.push(GotoIf(block_label.addr));
    instructions.push(Goto(end.addr));
    instructions.push(AddrLabel(block_label));
    instructions.extend(block);
    instructions.push(Goto(begin.addr));
    instructions.push(AddrLabel(end));
    instructions.push(DelLoopCtx);
    Some(instructions)
}

/// Build the intructions needed to run a BinaryOp expression
/// see:
/// * `preprocess_numerical_op`
/// * `preprocess_comparison_op`
/// * `preprocess_logical_op`
/// for details
pub fn preprocess_binary_op(op: &BinaryOp, sub_instructions: Vec<Vec<PreInstruction>>, labels: &mut LabelGenerator) -> Option<Vec<PreInstruction>> {
    match op {
        Numerical(num_op) => preprocess_numerical_op(num_op, sub_instructions),
        Comparison(comp_op) => preprocess_comparison_op(comp_op, sub_instructions),
        Logical(logical_op) => preprocess_logical_op(logical_op, sub_instructions, labels),
    }
}
    
#[cfg(test)]
mod test {
    use crate::ast::Ast;
    use crate::compiler::compiler::Compiler;
    use crate::compiler::preprocessors::{PreInstruction,PreValue,Addr,AddrKind};
    use PreInstruction::*;
    use PreValue::*;

    #[test]
    fn test_if_instruction_set() {
        let ast = Ast::from_str(r#"
        if (true) {
          "true_block";
        } 
        "#).unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
			vec![
                Val(Bool(true)),
                GotoIf(0),
                Goto(1),
                AddrLabel(Addr { addr: 0, kind: AddrKind::Jump }),
                NewStack,
                Val(Str("true_block".into())),
                DelStack,
                AddrLabel(Addr { addr: 1, kind: AddrKind::Jump }),
            ],
		);
        let ast = Ast::from_str(r#"
        if (true) {
          "true_block";
        } else {
          "false_block";
        }"#).unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
			vec![
                Val(Bool(true)),
                GotoIf(0),
                NewStack,
                Val(Str("false_block".into())),
                DelStack,
                Goto(1),
                AddrLabel(Addr { addr: 0, kind: AddrKind::Jump }),
                NewStack,
                Val(Str("true_block".into())),
                DelStack,
                AddrLabel(Addr { addr: 1, kind: AddrKind::Jump }),
            ],
		);
    }

    #[test]
    fn test_let_instruction_set() {
        let ast = Ast::from_str("let some_ref;").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                NewRef("some_ref".into()),
            ],
        );
        let ast = Ast::from_str("let some_ref = true;").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Val(Bool(true)),
                NewRef("some_ref".into()),
                Store("some_ref".into()),
            ],
        );
    }

    #[test]
    fn test_local_instruction_set() {
        let ast = Ast::from_str("a;").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Load("a".into()),
            ],
        );
    }
    #[test]
    fn test_block_instruction_set() {
        let ast = Ast::from_str("{ 1; 2; 3; }").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                NewStack,
                Val(Num(1.)),
                ClearStack,
                Val(Num(2.)),
                ClearStack,
                Val(Num(3.)),
                DelStack,
            ],
        );
    }
    #[test]
    fn test_call_instruction_set() {
        // test with args
        let ast = Ast::from_str("foo(a, b)").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Load("b".into()),
                Load("a".into()),
                PushToNext(2),
                Load("foo".into()),
                FnCall,
            ],
        );
        // test with one arg
        let ast = Ast::from_str("foo(a)").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Load("a".into()),
                PushToNext(1),
                Load("foo".into()),
                FnCall,
            ],
        );
        // test without args
        let ast = Ast::from_str("foo()").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Load("foo".into()),
                FnCall,
            ],
        );
    }
    #[test]
    fn test_function_decl_instruction_set() {
        let ast = Ast::from_str("function foo(a, b) { return true; }").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Goto(1),  // skip function block if we're not calling it
                AddrLabel(Addr { addr: 0, kind: AddrKind::BeginFunction } ), // begin address
                NewRef("a".into()), // first arg 
                Store("a".into()),
                NewRef("b".into()), // 2nd arg
                Store("b".into()),
                Val(Bool(true)), // function block
                PushToNext(1),   
                FnRet,
                AddrLabel(Addr { addr: 1, kind: AddrKind::EndFunction } ), // begin address
                Val(Function(0)), // put function address into a `foo` var
                NewRef("foo".into()),
                Store("foo".into()),
            ],
        );
        // test automatic "return undefined"
        let ast = Ast::from_str("function foo(a, b) { }").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Goto(1),  // skip function block if we're not calling it
                AddrLabel(Addr { addr: 0, kind: AddrKind::BeginFunction } ), // begin address
                NewRef("a".into()), // first arg 
                Store("a".into()),
                NewRef("b".into()), // 2nd arg
                Store("b".into()),
                Val(Undefined),  // backup return call
                PushToNext(1),
                FnRet,
                AddrLabel(Addr { addr: 1, kind: AddrKind::EndFunction } ), // begin address
                Val(Function(0)), // put function address into a `foo` var
                NewRef("foo".into()),
                Store("foo".into()),
            ],
        );
    }
    #[test]
    fn test_assign_instruction_set() {
        let ast = Ast::from_str("a = 2").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Val(Num(2.)),
                Store("a".into()),
            ],
        );
    }
    #[test]
    fn test_numerical_binary_op_instruction_set() {
        let ast = Ast::from_str("1 + 2").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Val(Num(2.)),
                Val(Num(1.)),
                Add,
            ],
        );
    }
    #[test]
    fn test_comparison_binary_op_instruction_set() {
        let ast = Ast::from_str("1 <= 2").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Val(Num(2.)),
                Val(Num(1.)),
                LessThanOrEqual
            ],
        );
    }
    #[test]
    fn test_logical_binary_op_instruction_set() {
        // test AND
        let ast = Ast::from_str("true && false").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Val(Bool(true)),
                GotoIf(1), // success path
                Goto(0), // failure path
                AddrLabel(Addr { addr: 1, kind: AddrKind::Jump }),
                Val(Bool(false)),
                And,
                AddrLabel(Addr { addr: 0, kind: AddrKind::Jump }),
            ],
        );
        // test OR
        let ast = Ast::from_str("true || false").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                Val(Bool(true)),
                GotoIf(0), // success path
                Val(Bool(false)),
                Or,
                AddrLabel(Addr { addr: 0, kind: AddrKind::Jump }),
            ],
        );
    }
    #[test]
    fn test_unary_op_instruction_set() {
        let ast = Ast::from_str("!true").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![Val(Bool(true)), Not],
        );
        let ast = Ast::from_str("+1").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![Val(Num(1.)), Plus],
        );
        let ast = Ast::from_str("-1").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![Val(Num(1.)), Minus],
        );
    }
    #[test]
    fn test_while_instruction_set() {
        let ast = Ast::from_str("while(a < 2) { a = a + 1; }").unwrap();
        assert_eq!(
            Compiler::preprocess(&ast.root).unwrap(),
            vec![
                NewLoopCtx,
                AddrLabel(Addr { addr: 0, kind: AddrKind::BeginLoop }), // begin
                Val(Num(2.)),
                Load("a".into()),
                LessThan,
                GotoIf(1),
                Goto(2),
                AddrLabel(Addr { addr: 1, kind: AddrKind::Jump }), // block 
                NewStack,
                Val(Num(1.)),
                Load("a".into()),
                Add,
                Store("a".into()),
                DelStack,
                Goto(0),
                AddrLabel(Addr { addr: 2, kind: AddrKind::EndLoop }), // block 
                DelLoopCtx,
            ],
        );
    }
}

