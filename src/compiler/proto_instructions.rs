/// This file describes the intermediate representation of an Instruction set
/// as generated by the compiler preprocess pass
///
use crate::ast::{
    Const,
};

/// Label are references to code location,
/// those are later solved into addresses 
pub type Label = usize;

#[derive(Debug,Clone,PartialEq)]
pub enum ProtoValue {
    /// any quoted string
    Str(String),
    /// int or float
    Num(f64),
    /// boolean `true` or `false`
    Bool(bool),
    /// A function address
    Function(Label),
    /// 
    Null,
    /// 
    Undefined,
}
impl ProtoValue {
    pub fn from_const(expr: &Const) -> Self { 
        return match *expr {
            Const::Str(ref s) => Self::Str(s.clone()),
            Const::Num(n) => Self::Num(n),
            Const::Bool(b) => Self::Bool(b),
            Const::Null => Self::Null,
            Const::Undefined => Self::Undefined,
        };
    }
}

#[derive(Debug,Clone,PartialEq,Copy)]
pub enum AddrKind {
    Jump,
    BeginLoop,
    EndLoop,
    BeginFunction,
    EndFunction,
}

#[derive(Debug,Clone,PartialEq,Copy)]
pub struct Addr {
    pub kind: AddrKind,
    pub addr: Label,
}

/// This struct's only job is to generates uniq 
/// Labels (basically IDs)
#[derive(Debug,Clone,PartialEq)]
pub struct LabelGenerator {
    addr: Label,
}

impl Iterator for LabelGenerator {
    type Item = Label;

    fn next(&mut self) -> Option<Self::Item> {
        let addr = self.addr;
        self.addr += 1;
        Some(addr)
    }
}

impl LabelGenerator {
    pub fn new() -> Self {
        Self { addr: 0 }
    }

    /// Returns an unused `begin loop` address
    pub fn begin_loop(&mut self) -> Addr {
        Addr { 
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::BeginLoop,
        }
    }

    /// Returns an unused `end loop` address
    pub fn end_loop(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::EndLoop,
        }
    }

    /// Returns an unused `jump to` address
    pub fn jump_to(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::Jump,
        }
    }

    /// Returns an unused `begin function` label address
    pub fn begin_function(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::BeginFunction,
        }
    }

    /// Returns an unused `end function` label address
    pub fn end_function(&mut self) -> Addr {
        Addr {
            addr: self.next().unwrap(), // cannot fail
            kind: AddrKind::EndFunction,
        }
    }

}

#[derive(Debug,Clone,PartialEq)]
pub enum ProtoInstruction {
    // jump
    Goto(Label),
    GotoIf(Label),
    AddrLabel(Addr),
    Break,
    Continue,
    // Variable bindings
    NewRef(String), 
    Load(String),
    /// pop the stack and store the value into the variable pointed by `String`
    /// if the stack is empty, store `Value::Undefined`
    Store(String), 
    // value 
    Val(ProtoValue),
    // Arguments and return value
    /// Call a function
    FnCall, // doesn't need to push a new stack, but must create a new environnement
    /// Exit a function
    FnRet,  // doesn't need to pop a stack, but must delete the last environnement
    // stack machine states
    /// move the `n` last elements of the current stack to a passthrough buffer
    PushToNext(usize),
    /// Creates a new stack
    /// then, if any element are in the passthrough buffer push those elements to it
    NewStack,
    /// clear all values of the current stack
    ClearStack,
    /// remove the last stack
    /// then if any element are in the passthrough buffer push those elements to the current one
    DelStack,
    /// Creates a new Loop context
    NewLoopCtx,
    /// remove the last loop context
    DelLoopCtx,
    /// remove the last loop context
    PopToLoopCtx,
    // Native function
    // ... TODO
    // Binary Instructions
    // * Numerical
    Add,
    Sub,
    Div,
    Mul,
    Pow,
    Mod,
    // * Comparison
    Equal,
    NotEqual,
    GreaterThan,
    GreaterThanOrEqual,
    LessThan,
    LessThanOrEqual,
    // * Logical
    And,
    Or,
    // Unary Instructions
    Minus,
    Plus,
    Not,
}

